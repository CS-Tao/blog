---
title: GraphQL - 重新定义你的 API
date: 2019-09-20 08:30:31
categories: 技术相关
tags: [GraphQL]
toc: true
---
<img src="https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/graphql.png" width="45%" height="45%">

# 缘起

最近正值我们伟大祖国的 70 周年大庆，祝祖国母亲生日快乐！🎉🎉🎉 也为我被封的 IP 默哀 3 秒钟
IP 被封意味着我持续记录快满一年的软件使用记录服务被迫中断
于是乎我希望找到一种方法，可以实现无服务器地记录软件的使用情况
很自然地我把矛头对准了 GitHub issues 的评论功能
一个伟大的想法应运而生 —— **将每次使用记录的访问地址改为 GitHub 添加评论的 API**
由于 GitHub API 的最新版本(v4)是基于 GraphQL 规范的，我便开始了 GraphQL 的学习之旅

# 缘灭

我突然发现 GitHub issues 的评论功能需要用户提供公共仓库的操作权限
这和我最开始向用户申请的"只需要获取公共数据的权限"不一致
不得已，我只能暂时搁置这一解决方案，GraphQL，我们有缘再见...

<!-- more -->

# 正文

俗话说对事不对人，就这样放弃学习 GraphQL 是不明智的，而且 GraphQL 并不是很难，相反它地设计理念很容易让人理解，甚至说这是一趟学习之旅都有点夸大了，只要使用者不是希望开发一个基于 GraphQL 的服务框架，单纯地学习 GraphQL 的使用方法还是很快的

## 理念

学习 GraphQL 并不是学习一门技术，而是学习一种架构思想。不同于传统的 RESTful 风格的 API 架构，GraphQL 只有一个 API 入口来提供 http 服务，而且只需要请求一次便能得到所有数据。最有趣的一点是，通过 GraphQL 请求的数据格式完全由客户端决定，并且完全和客户端的查询语句保持一致

记得有一次去面试，面试官问我有没有做过前后端分离开发，有没有使用过 Swagger。答案是肯定的，但是这不禁让人思考，在云服务技术盛行的今天，RESTful 架构如此分散的数据请求方式是不是正在逐渐与时代脱轨？

作为连接现代应用程序到云服务的全面解决方案，GraphQL 使所有应用程序数据和服务集中在同一个地方，而且具有一致、安全且易于使用的界面。使用 GraphQL 规范定义 API，服务端开发者不需要再关心客户端需要哪些服务，只需要专注于定义数据的结构和关系以及每个数据的解析方式。客户端开发者可以不再关心单个 API 的功能和返回的数据结构，只需要关心客户端所需要的数据是怎样组织的

这也意味着类似于 Swagger 的 API 说明文档将不再被需要，因为当服务器定义了数据的结构和关系，一张描述服务器所有数据的数据图便生成了，通过这张图，任何客户端开发者都可以很容易地去了解如何获取所需的数据

## 语法

[https://graphql.cn/learn/](https://graphql.cn/learn/)

## 权限

GraphQL 规范倡导的的权限机制不是针对某个服务建立的，而是针对每一条数据建立的，并且权限验证操作应当委托给业务逻辑层。在服务器实现过程中，每个字段的解析函数将会获得一个上下文参数用以访问当前用户的信息，用以验证权限

## 缓存

缓存机制可以减小服务器和网络负担，传统的缓存是根据 URL 建立的，这是因为通过 URL 可以区分不同的服务，但 GraphQL 使用唯一的 URL 入口提供服务，无法根据 URL 建立缓存。GraphQL 提供的缓存机制是给每个字段赋予全局唯一标识符(GUID)，提供不同标识符区分不同字段，并针对每个字段提供缓存

## 更新

传统的 API 依靠版本控制升级不同的版本，GraphQL 推荐使用持续演进的方式进行 API 的更新，通过标记字段将其从最新的 API 中移除，但不会影响之前服务的使用，这样的方式使得开发者无需一次又一次地学习新 API 的使用方式，减少开发时间

# 后记

GraphQL 是一个很完善的规范，已经有了所有主流语言的实现，但我却不知道如何对它进行实践

我把它推荐给看到这篇文章的你们，希望你们有机会去学习和实践这门全新的技术，让新技术创造新世界
